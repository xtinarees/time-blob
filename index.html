<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Time Blob</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
      background: #0a0a0a;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';

    // ========================================
    // Seeded PRNG (Mulberry32)
    // ========================================
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    }

    // ========================================
    // Simplex Noise Implementation
    // ========================================
    class SimplexNoise {
      constructor(random = Math.random) {
        this.p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) this.p[i] = i;
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(random() * (i + 1));
          [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
        }
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        for (let i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255];
          this.permMod12[i] = this.perm[i] % 12;
        }
      }

      noise3D(x, y, z) {
        const F3 = 1/3, G3 = 1/6;
        const grad3 = [
          [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
          [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
          [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
        ];

        const s = (x + y + z) * F3;
        const i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
        const t = (i + j + k) * G3;
        const X0 = i - t, Y0 = j - t, Z0 = k - t;
        const x0 = x - X0, y0 = y - Y0, z0 = z - Z0;

        let i1, j1, k1, i2, j2, k2;
        if (x0 >= y0) {
          if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
          else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
          else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
        } else {
          if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
          else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
          else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
        }

        const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2*G3, y2 = y0 - j2 + 2*G3, z2 = z0 - k2 + 2*G3;
        const x3 = x0 - 1 + 3*G3, y3 = y0 - 1 + 3*G3, z3 = z0 - 1 + 3*G3;

        const ii = i & 255, jj = j & 255, kk = k & 255;

        const dot = (g, x, y, z) => g[0]*x + g[1]*y + g[2]*z;

        let n0 = 0, n1 = 0, n2 = 0, n3 = 0;
        let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
        if (t0 >= 0) {
          const gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
          t0 *= t0;
          n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);
        }
        let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
        if (t1 >= 0) {
          const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
          t1 *= t1;
          n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);
        }
        let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
        if (t2 >= 0) {
          const gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
          t2 *= t2;
          n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);
        }
        let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
        if (t3 >= 0) {
          const gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];
          t3 *= t3;
          n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);
        }
        return 32 * (n0 + n1 + n2 + n3);
      }
    }

    // ========================================
    // Time Functions
    // ========================================
    function getTimeProgress() {
      const now = new Date();
      const secondsSinceMidnight =
        now.getUTCHours() * 3600 +
        now.getUTCMinutes() * 60 +
        now.getUTCSeconds() +
        now.getUTCMilliseconds() / 1000;
      return secondsSinceMidnight / 86400;
    }

    function getTodayString() {
      return new Date().toISOString().slice(0, 10);
    }

    // ========================================
    // Initialize Daily Seed
    // ========================================
    const today = getTodayString();
    const seed = hashString(today);
    const random = mulberry32(seed);
    const noise = new SimplexNoise(random);

    // ========================================
    // Daily Color Palette
    // ========================================
    const primaryHue = random() * 360;
    const goldenRatio = 137.5;
    const secondaryHue = (primaryHue + goldenRatio) % 360;
    const tertiaryHue = (secondaryHue + goldenRatio) % 360;

    const baseColor = new THREE.Color().setHSL(primaryHue / 360, 0.7, 0.5);
    const accentColor = new THREE.Color().setHSL(secondaryHue / 360, 0.8, 0.6);

    // Daily noise parameters
    const noiseScale = 0.8 + random() * 0.6;
    const rotationSpeed = 0.001 + random() * 0.002;
    const baseAmplitude = 0.1 + random() * 0.1;
    const maxAmplitude = 0.4 + random() * 0.3;

    // ========================================
    // Scene Setup
    // ========================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // ========================================
    // Environment Map
    // ========================================
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    function createGradientTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      const gradient = ctx.createLinearGradient(0, 0, 0, 512);
      gradient.addColorStop(0, `hsl(${primaryHue}, 30%, 15%)`);
      gradient.addColorStop(0.5, `hsl(${secondaryHue}, 20%, 8%)`);
      gradient.addColorStop(1, `hsl(${tertiaryHue}, 25%, 12%)`);

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);

      return new THREE.CanvasTexture(canvas);
    }

    const envTexture = createGradientTexture();
    envTexture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = pmremGenerator.fromEquirectangular(envTexture).texture;

    // ========================================
    // Lighting
    // ========================================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const backLight = new THREE.DirectionalLight(accentColor, 0.5);
    backLight.position.set(-3, -2, -5);
    scene.add(backLight);

    // ========================================
    // Geometry & Material
    // ========================================
    const geometry = new THREE.IcosahedronGeometry(1.5, 5);
    const positionAttribute = geometry.getAttribute('position');
    const originalPositions = new Float32Array(positionAttribute.array);

    const material = new THREE.MeshPhysicalMaterial({
      color: baseColor,
      metalness: 0.1,
      roughness: 0.2,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
      iridescence: 1.0,
      iridescenceIOR: 1.5,
      iridescenceThicknessRange: [100, 400],
      transmission: 0.3,
      thickness: 1.5,
      envMapIntensity: 1.0,
      side: THREE.DoubleSide
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // ========================================
    // Geometry Update Function
    // ========================================
    function updateGeometry(t, elapsedTime) {
      const positions = positionAttribute.array;
      const amplitude = baseAmplitude + (maxAmplitude - baseAmplitude) * t;
      const frequency = noiseScale * (1 + t * 0.5);

      for (let i = 0; i < positions.length; i += 3) {
        const ox = originalPositions[i];
        const oy = originalPositions[i + 1];
        const oz = originalPositions[i + 2];

        const length = Math.sqrt(ox * ox + oy * oy + oz * oz);
        const nx = ox / length;
        const ny = oy / length;
        const nz = oz / length;

        // Multi-octave noise for organic look
        let noiseValue = 0;
        noiseValue += noise.noise3D(nx * frequency, ny * frequency, nz * frequency + elapsedTime * 0.1) * 1.0;
        noiseValue += noise.noise3D(nx * frequency * 2, ny * frequency * 2, nz * frequency * 2 + elapsedTime * 0.15) * 0.5;
        noiseValue += noise.noise3D(nx * frequency * 4, ny * frequency * 4, nz * frequency * 4 + elapsedTime * 0.2) * 0.25;

        const displacement = 1 + noiseValue * amplitude;

        positions[i] = ox * displacement;
        positions[i + 1] = oy * displacement;
        positions[i + 2] = oz * displacement;
      }

      positionAttribute.needsUpdate = true;
      geometry.computeVertexNormals();
    }

    // ========================================
    // Animation Loop
    // ========================================
    const clock = new THREE.Clock();
    let currentDay = today;

    function animate() {
      requestAnimationFrame(animate);

      // Check for day change
      const nowDay = getTodayString();
      if (nowDay !== currentDay) {
        window.location.reload();
      }

      const t = getTimeProgress();
      const elapsedTime = clock.getElapsedTime();

      updateGeometry(t, elapsedTime);

      mesh.rotation.y += rotationSpeed;
      mesh.rotation.x += rotationSpeed * 0.5;

      renderer.render(scene, camera);
    }

    // ========================================
    // Resize Handler
    // ========================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // ========================================
    // Start
    // ========================================
    animate();
  </script>
</body>
</html>
