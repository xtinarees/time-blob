<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Time Blob</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        background: #f0f0f0;
      }
      canvas {
        display: block;
      }
      /* Test Controls */
      #test-controls {
        display: none;
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 10px;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        color: #fff;
        z-index: 1000;
        min-width: 280px;
      }
      #test-controls.visible {
        display: block;
      }
      #test-controls h3 {
        margin: 0 0 15px 0;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #888;
      }
      #test-controls label {
        display: block;
        margin-bottom: 8px;
        font-size: 13px;
        color: #ccc;
      }
      #test-controls input[type="range"] {
        width: 100%;
        margin-bottom: 5px;
        cursor: pointer;
      }
      #test-controls .time-display {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 15px;
        font-family: monospace;
      }
      #test-controls button {
        width: 100%;
        padding: 10px 15px;
        background: #333;
        border: 1px solid #555;
        color: #fff;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      }
      #test-controls button:hover {
        background: #444;
      }
      #test-controls .seed-display {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #333;
        font-size: 12px;
        color: #666;
      }
      #test-controls .section {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #333;
      }
      #test-controls .section h4 {
        margin: 0 0 10px 0;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #888;
      }
      #test-controls .control-row {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        gap: 10px;
      }
      #test-controls .control-row label {
        flex: 0 0 120px;
        margin-bottom: 0;
        font-size: 11px;
      }
      #test-controls .control-row input[type="range"] {
        flex: 1;
        margin-bottom: 0;
      }
      #test-controls .control-row .value {
        flex: 0 0 45px;
        text-align: right;
        font-size: 11px;
        font-family: monospace;
        color: #aaa;
      }
      #test-controls .scrollable {
        max-height: 400px;
        overflow-y: auto;
        padding-right: 5px;
      }
      #test-controls .scrollable::-webkit-scrollbar {
        width: 6px;
      }
      #test-controls .scrollable::-webkit-scrollbar-track {
        background: #222;
        border-radius: 3px;
      }
      #test-controls .scrollable::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 3px;
      }
    </style>
    <script src="config.js"></script>
  </head>
  <body>
    <div id="test-controls">
      <h3>Test Mode</h3>
      <label>UTC Time</label>
      <div class="time-display" id="time-display">00:00:00</div>
      <input
        type="range"
        id="time-slider"
        min="0"
        max="86400"
        step="1"
        value="0"
      />
      <button id="new-blob-btn">Generate New Blob</button>
      <div class="seed-display">Seed: <span id="seed-display">-</span></div>

      <div class="section">
        <h4>Material Properties</h4>
        <div class="scrollable">
          <div class="control-row">
            <label>Metalness</label>
            <input
              type="range"
              id="mat-metalness"
              min="0"
              max="1"
              step="0.01"
              value="0.1"
            />
            <span class="value" id="val-metalness">0.10</span>
          </div>
          <div class="control-row">
            <label>Roughness</label>
            <input
              type="range"
              id="mat-roughness"
              min="0"
              max="1"
              step="0.01"
              value="0.2"
            />
            <span class="value" id="val-roughness">0.20</span>
          </div>
          <div class="control-row">
            <label>Clearcoat</label>
            <input
              type="range"
              id="mat-clearcoat"
              min="0"
              max="1"
              step="0.01"
              value="1.0"
            />
            <span class="value" id="val-clearcoat">1.00</span>
          </div>
          <div class="control-row">
            <label>Clearcoat Rough</label>
            <input
              type="range"
              id="mat-clearcoatRoughness"
              min="0"
              max="1"
              step="0.01"
              value="0.1"
            />
            <span class="value" id="val-clearcoatRoughness">0.10</span>
          </div>
          <div class="control-row">
            <label>Iridescence</label>
            <input
              type="range"
              id="mat-iridescence"
              min="0"
              max="1"
              step="0.01"
              value="1.0"
            />
            <span class="value" id="val-iridescence">1.00</span>
          </div>
          <div class="control-row">
            <label>Iridescence IOR</label>
            <input
              type="range"
              id="mat-iridescenceIOR"
              min="1"
              max="2.333"
              step="0.01"
              value="1.5"
            />
            <span class="value" id="val-iridescenceIOR">1.50</span>
          </div>
          <div class="control-row">
            <label>Irid. Thick Min</label>
            <input
              type="range"
              id="mat-iridescenceThicknessMin"
              min="0"
              max="1000"
              step="10"
              value="100"
            />
            <span class="value" id="val-iridescenceThicknessMin">100</span>
          </div>
          <div class="control-row">
            <label>Irid. Thick Max</label>
            <input
              type="range"
              id="mat-iridescenceThicknessMax"
              min="0"
              max="1000"
              step="10"
              value="400"
            />
            <span class="value" id="val-iridescenceThicknessMax">400</span>
          </div>
          <div class="control-row">
            <label>Transmission</label>
            <input
              type="range"
              id="mat-transmission"
              min="0"
              max="1"
              step="0.01"
              value="0.3"
            />
            <span class="value" id="val-transmission">0.30</span>
          </div>
          <div class="control-row">
            <label>Thickness</label>
            <input
              type="range"
              id="mat-thickness"
              min="0"
              max="5"
              step="0.1"
              value="1.5"
            />
            <span class="value" id="val-thickness">1.50</span>
          </div>
          <div class="control-row">
            <label>Env Map Intensity</label>
            <input
              type="range"
              id="mat-envMapIntensity"
              min="0"
              max="3"
              step="0.1"
              value="1.0"
            />
            <span class="value" id="val-envMapIntensity">1.00</span>
          </div>
          <div class="control-row">
            <label>Sheen</label>
            <input
              type="range"
              id="mat-sheen"
              min="0"
              max="1"
              step="0.01"
              value="0"
            />
            <span class="value" id="val-sheen">0.00</span>
          </div>
          <div class="control-row">
            <label>Sheen Roughness</label>
            <input
              type="range"
              id="mat-sheenRoughness"
              min="0"
              max="1"
              step="0.01"
              value="1.0"
            />
            <span class="value" id="val-sheenRoughness">1.00</span>
          </div>
          <div class="control-row">
            <label>Specular Intensity</label>
            <input
              type="range"
              id="mat-specularIntensity"
              min="0"
              max="2"
              step="0.01"
              value="1.0"
            />
            <span class="value" id="val-specularIntensity">1.00</span>
          </div>
          <div class="control-row">
            <label>IOR</label>
            <input
              type="range"
              id="mat-ior"
              min="1"
              max="2.333"
              step="0.01"
              value="1.5"
            />
            <span class="value" id="val-ior">1.50</span>
          </div>
          <div class="control-row">
            <label>Reflectivity</label>
            <input
              type="range"
              id="mat-reflectivity"
              min="0"
              max="1"
              step="0.01"
              value="0.5"
            />
            <span class="value" id="val-reflectivity">0.50</span>
          </div>
        </div>
      </div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";

      // ========================================
      // Test Mode Configuration
      // ========================================
      const TEST_MODE = window.TIME_BLOB_CONFIG?.TEST_MODE || false;
      let testTimeOverride = null; // null = use real time, number = seconds since midnight
      let testSeedCounter = 0; // Increment to generate new blobs

      // ========================================
      // Seeded PRNG (Mulberry32)
      // ========================================
      function mulberry32(seed) {
        return function () {
          let t = (seed += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return Math.abs(hash);
      }

      // ========================================
      // Simplex Noise Implementation
      // ========================================
      class SimplexNoise {
        constructor(random = Math.random) {
          this.p = new Uint8Array(256);
          for (let i = 0; i < 256; i++) this.p[i] = i;
          for (let i = 255; i > 0; i--) {
            const j = Math.floor(random() * (i + 1));
            [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
          }
          this.perm = new Uint8Array(512);
          this.permMod12 = new Uint8Array(512);
          for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
            this.permMod12[i] = this.perm[i] % 12;
          }
        }

        noise3D(x, y, z) {
          const F3 = 1 / 3,
            G3 = 1 / 6;
          const grad3 = [
            [1, 1, 0],
            [-1, 1, 0],
            [1, -1, 0],
            [-1, -1, 0],
            [1, 0, 1],
            [-1, 0, 1],
            [1, 0, -1],
            [-1, 0, -1],
            [0, 1, 1],
            [0, -1, 1],
            [0, 1, -1],
            [0, -1, -1],
          ];

          const s = (x + y + z) * F3;
          const i = Math.floor(x + s),
            j = Math.floor(y + s),
            k = Math.floor(z + s);
          const t = (i + j + k) * G3;
          const X0 = i - t,
            Y0 = j - t,
            Z0 = k - t;
          const x0 = x - X0,
            y0 = y - Y0,
            z0 = z - Z0;

          let i1, j1, k1, i2, j2, k2;
          if (x0 >= y0) {
            if (y0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            } else if (x0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            }
          } else {
            if (y0 < z0) {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else if (x0 < z0) {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            }
          }

          const x1 = x0 - i1 + G3,
            y1 = y0 - j1 + G3,
            z1 = z0 - k1 + G3;
          const x2 = x0 - i2 + 2 * G3,
            y2 = y0 - j2 + 2 * G3,
            z2 = z0 - k2 + 2 * G3;
          const x3 = x0 - 1 + 3 * G3,
            y3 = y0 - 1 + 3 * G3,
            z3 = z0 - 1 + 3 * G3;

          const ii = i & 255,
            jj = j & 255,
            kk = k & 255;

          const dot = (g, x, y, z) => g[0] * x + g[1] * y + g[2] * z;

          let n0 = 0,
            n1 = 0,
            n2 = 0,
            n3 = 0;
          let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
          if (t0 >= 0) {
            const gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
            t0 *= t0;
            n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);
          }
          let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
          if (t1 >= 0) {
            const gi1 =
              this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
            t1 *= t1;
            n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);
          }
          let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
          if (t2 >= 0) {
            const gi2 =
              this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
            t2 *= t2;
            n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);
          }
          let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
          if (t3 >= 0) {
            const gi3 =
              this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];
            t3 *= t3;
            n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);
          }
          return 32 * (n0 + n1 + n2 + n3);
        }
      }

      // ========================================
      // Time Functions
      // ========================================
      function getTimeProgress() {
        // In test mode, use override if set
        if (TEST_MODE && testTimeOverride !== null) {
          return testTimeOverride / 86400;
        }
        const now = new Date();
        const secondsSinceMidnight =
          now.getUTCHours() * 3600 +
          now.getUTCMinutes() * 60 +
          now.getUTCSeconds() +
          now.getUTCMilliseconds() / 1000;
        return secondsSinceMidnight / 86400;
      }

      function getTodayString() {
        return new Date().toISOString().slice(0, 10);
      }

      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
      }

      // ========================================
      // Scene Setup
      // ========================================
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        100,
      );
      camera.position.z = 5;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      document.body.appendChild(renderer.domElement);

      // ========================================
      // Environment Map
      // ========================================
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      // ========================================
      // Blob State (mutable for regeneration)
      // ========================================
      let blobState = {
        noise: null,
        primaryHue: 0,
        secondaryHue: 0,
        tertiaryHue: 0,
        baseColor: null,
        accentColor: null,
        backgroundColor: null,
        noiseScale: 0,
        rotationSpeed: 0,
        baseAmplitude: 0,
        maxAmplitude: 0,
        seed: 0,
        seedString: "",
      };

      let mesh = null;
      let geometry = null;
      let material = null;
      let positionAttribute = null;
      let originalPositions = null;
      let backLight = null;

      function initializeBlobState(seedString) {
        const seed = hashString(seedString);
        const random = mulberry32(seed);
        const noise = new SimplexNoise(random);

        const primaryHue = random() * 360;
        const goldenRatio = 137.5;
        const secondaryHue = (primaryHue + goldenRatio) % 360;
        const tertiaryHue = (secondaryHue + goldenRatio) % 360;
        const backgroundHue = (primaryHue + 180) % 360;

        blobState = {
          noise,
          primaryHue,
          secondaryHue,
          tertiaryHue,
          baseColor: new THREE.Color("blue"),
          accentColor: new THREE.Color("pink"),
          backgroundColor: new THREE.Color("orange"),
          noiseScale: 1,
          rotationSpeed: 0.001 + random() * 0.002,
          baseAmplitude: 0,
          maxAmplitude: 1.5,
          seed,
          seedString,
        };

        return blobState;
      }

      function createEnvironmentMap() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, `hsl(${blobState.primaryHue}, 30%, 15%)`);
        gradient.addColorStop(0.5, `hsl(${blobState.secondaryHue}, 20%, 8%)`);
        gradient.addColorStop(1, `hsl(${blobState.tertiaryHue}, 25%, 12%)`);

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);

        const texture = new THREE.CanvasTexture(canvas);
        texture.mapping = THREE.EquirectangularReflectionMapping;
        return texture;
      }

      function createBlob() {
        // Remove old mesh if exists
        if (mesh) {
          scene.remove(mesh);
          geometry.dispose();
          material.dispose();
        }
        if (backLight) {
          scene.remove(backLight);
        }

        // Create environment map
        const envTexture = createEnvironmentMap();
        scene.environment =
          pmremGenerator.fromEquirectangular(envTexture).texture;

        // Set background color
        scene.background = blobState.backgroundColor;

        // Create geometry
        geometry = new THREE.IcosahedronGeometry(1, 7);
        positionAttribute = geometry.getAttribute("position");
        originalPositions = new Float32Array(positionAttribute.array);

        // Add vertex colors attribute for gradient effect
        const colors = new Float32Array(positionAttribute.count * 3);
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        // Create material
        material = new THREE.MeshPhysicalMaterial({
          vertexColors: true,
          metalness: 0.1,
          roughness: 0.2,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          iridescence: 1.0,
          iridescenceIOR: 1.5,
          iridescenceThicknessRange: [100, 400],
          transmission: 0.3,
          thickness: 1.5,
          envMapIntensity: 1.0,
          side: THREE.DoubleSide,
        });

        // Create mesh
        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Update back light color
        // backLight = new THREE.DirectionalLight(blobState.accentColor, 0.5);
        // backLight.position.set(-3, -2, -5);
        // scene.add(backLight);
      }

      // ========================================
      // Lighting (static lights)
      // ========================================
      // const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      // scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // ========================================
      // Initialize
      // ========================================
      const today = getTodayString();
      initializeBlobState(today);
      createBlob();

      // ========================================
      // Geometry Update Function
      // ========================================
      function updateGeometry(t, elapsedTime) {
        const positions = positionAttribute.array;
        const normalAttribute = geometry.getAttribute("normal");
        const normalArray = normalAttribute.array;
        const amplitude =
          blobState.baseAmplitude +
          (blobState.maxAmplitude - blobState.baseAmplitude) * t;
        const frequency = blobState.noiseScale * (1 + t * 0.5);
        const eps = 0.0001;

        // Multi-octave noise sampling helper
        const sampleNoise = (sx, sy, sz) => {
          let v = 0;
          v +=
            blobState.noise.noise3D(
              sx * frequency,
              sy * frequency,
              sz * frequency + elapsedTime * 0.1,
            ) * 1.0;
          v +=
            blobState.noise.noise3D(
              sx * frequency * 2,
              sy * frequency * 2,
              sz * frequency * 2 + elapsedTime * 0.15,
            ) * 0.5;
          v +=
            blobState.noise.noise3D(
              sx * frequency * 4,
              sy * frequency * 4,
              sz * frequency * 4 + elapsedTime * 0.2,
            ) * 0.25;
          return v;
        };

        for (let i = 0; i < positions.length; i += 3) {
          const ox = originalPositions[i];
          const oy = originalPositions[i + 1];
          const oz = originalPositions[i + 2];

          const length = Math.sqrt(ox * ox + oy * oy + oz * oz);
          const nx = ox / length;
          const ny = oy / length;
          const nz = oz / length;

          const noiseValue = sampleNoise(nx, ny, nz);
          const displacement = 1 + noiseValue * amplitude;

          positions[i] = ox * displacement;
          positions[i + 1] = oy * displacement;
          positions[i + 2] = oz * displacement;

          // Compute smooth analytical normals via finite differences
          const nfx = sampleNoise(nx + eps, ny, nz);
          const nfy = sampleNoise(nx, ny + eps, nz);
          const nfz = sampleNoise(nx, ny, nz + eps);

          const gradX = ((nfx - noiseValue) / eps) * amplitude;
          const gradY = ((nfy - noiseValue) / eps) * amplitude;
          const gradZ = ((nfz - noiseValue) / eps) * amplitude;

          // Smooth normal = original normal - noise gradient
          let snx = nx - gradX;
          let sny = ny - gradY;
          let snz = nz - gradZ;
          const slen = Math.sqrt(snx * snx + sny * sny + snz * snz);
          normalArray[i] = snx / slen;
          normalArray[i + 1] = sny / slen;
          normalArray[i + 2] = snz / slen;
        }

        positionAttribute.needsUpdate = true;
        normalAttribute.needsUpdate = true;

        // Update vertex colors for gradient effect
        const colorAttribute = geometry.getAttribute("color");
        const colorArray = colorAttribute.array;

        for (let i = 0; i < positions.length; i += 3) {
          const y = positions[i + 1];
          // Normalize Y to 0-1 range (blob typically spans -2 to +2)
          const t = Math.max(0, Math.min(1, (y + 2) / 4));

          // Blend between base and accent colors
          const r =
            blobState.baseColor.r +
            (blobState.accentColor.r - blobState.baseColor.r) * t;
          const g =
            blobState.baseColor.g +
            (blobState.accentColor.g - blobState.baseColor.g) * t;
          const b =
            blobState.baseColor.b +
            (blobState.accentColor.b - blobState.baseColor.b) * t;

          colorArray[i] = r;
          colorArray[i + 1] = g;
          colorArray[i + 2] = b;
        }
        colorAttribute.needsUpdate = true;
      }

      // ========================================
      // Test Mode UI
      // ========================================
      if (TEST_MODE) {
        const controls = document.getElementById("test-controls");
        const timeSlider = document.getElementById("time-slider");
        const timeDisplay = document.getElementById("time-display");
        const newBlobBtn = document.getElementById("new-blob-btn");
        const seedDisplay = document.getElementById("seed-display");

        controls.classList.add("visible");

        // Initialize slider to current time
        const now = new Date();
        const currentSeconds =
          now.getUTCHours() * 3600 +
          now.getUTCMinutes() * 60 +
          now.getUTCSeconds();
        timeSlider.value = currentSeconds;
        timeDisplay.textContent = formatTime(currentSeconds);
        seedDisplay.textContent = blobState.seedString;

        timeSlider.addEventListener("input", (e) => {
          testTimeOverride = parseInt(e.target.value);
          timeDisplay.textContent = formatTime(testTimeOverride);
        });

        newBlobBtn.addEventListener("click", () => {
          testSeedCounter++;
          const newSeed = `${today}-test-${testSeedCounter}`;
          initializeBlobState(newSeed);
          createBlob();
          seedDisplay.textContent = newSeed;
          // Reset material sliders to default values
          resetMaterialSliders();
        });

        // Material property controls
        const materialProps = [
          { id: "metalness", prop: "metalness", decimals: 2 },
          { id: "roughness", prop: "roughness", decimals: 2 },
          { id: "clearcoat", prop: "clearcoat", decimals: 2 },
          { id: "clearcoatRoughness", prop: "clearcoatRoughness", decimals: 2 },
          { id: "iridescence", prop: "iridescence", decimals: 2 },
          { id: "iridescenceIOR", prop: "iridescenceIOR", decimals: 2 },
          { id: "transmission", prop: "transmission", decimals: 2 },
          { id: "thickness", prop: "thickness", decimals: 2 },
          { id: "envMapIntensity", prop: "envMapIntensity", decimals: 2 },
          { id: "sheen", prop: "sheen", decimals: 2 },
          { id: "sheenRoughness", prop: "sheenRoughness", decimals: 2 },
          { id: "specularIntensity", prop: "specularIntensity", decimals: 2 },
          { id: "ior", prop: "ior", decimals: 2 },
          { id: "reflectivity", prop: "reflectivity", decimals: 2 },
        ];

        materialProps.forEach(({ id, prop, decimals }) => {
          const slider = document.getElementById(`mat-${id}`);
          const valueDisplay = document.getElementById(`val-${id}`);

          slider.addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            material[prop] = value;
            valueDisplay.textContent = value.toFixed(decimals);
          });
        });

        // Special handling for iridescence thickness range (two sliders -> one array)
        const iridThickMinSlider = document.getElementById(
          "mat-iridescenceThicknessMin",
        );
        const iridThickMaxSlider = document.getElementById(
          "mat-iridescenceThicknessMax",
        );
        const iridThickMinVal = document.getElementById(
          "val-iridescenceThicknessMin",
        );
        const iridThickMaxVal = document.getElementById(
          "val-iridescenceThicknessMax",
        );

        iridThickMinSlider.addEventListener("input", (e) => {
          const min = parseFloat(e.target.value);
          const max = parseFloat(iridThickMaxSlider.value);
          material.iridescenceThicknessRange = [min, max];
          iridThickMinVal.textContent = Math.round(min);
        });

        iridThickMaxSlider.addEventListener("input", (e) => {
          const min = parseFloat(iridThickMinSlider.value);
          const max = parseFloat(e.target.value);
          material.iridescenceThicknessRange = [min, max];
          iridThickMaxVal.textContent = Math.round(max);
        });

        function resetMaterialSliders() {
          // Reset all sliders to match the newly created material
          const defaults = {
            metalness: 0.1,
            roughness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            iridescence: 1.0,
            iridescenceIOR: 1.5,
            transmission: 0.3,
            thickness: 1.5,
            envMapIntensity: 1.0,
            sheen: 0,
            sheenRoughness: 1.0,
            specularIntensity: 1.0,
            ior: 1.5,
            reflectivity: 0.5,
          };

          materialProps.forEach(({ id, prop, decimals }) => {
            const slider = document.getElementById(`mat-${id}`);
            const valueDisplay = document.getElementById(`val-${id}`);
            const value = defaults[prop];
            slider.value = value;
            valueDisplay.textContent = value.toFixed(decimals);
          });

          // Reset iridescence thickness
          iridThickMinSlider.value = 100;
          iridThickMaxSlider.value = 400;
          iridThickMinVal.textContent = "100";
          iridThickMaxVal.textContent = "400";
        }
      }

      // ========================================
      // Animation Loop
      // ========================================
      const clock = new THREE.Clock();
      let currentDay = today;

      function animate() {
        requestAnimationFrame(animate);

        // Check for day change (only in non-test mode)
        if (!TEST_MODE) {
          const nowDay = getTodayString();
          if (nowDay !== currentDay) {
            window.location.reload();
          }
        }

        const t = getTimeProgress();
        const elapsedTime = clock.getElapsedTime();

        updateGeometry(t, elapsedTime);

        // mesh.rotation.y += blobState.rotationSpeed;
        // mesh.rotation.x += blobState.rotationSpeed * 0.5;

        renderer.render(scene, camera);
      }

      // ========================================
      // Resize Handler
      // ========================================
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      });

      // ========================================
      // Start
      // ========================================
      animate();
    </script>
  </body>
</html>
